events {}

http {
    log_format main '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent" '
                    'backend=$upstream_addr request_time=$request_time';

    access_log /dev/stdout main;

    # Docker DNS for runtime resolution of names in $backend
    resolver 10.89.0.1 ipv6=off valid=10s;
    include mime.types;

    # Shared map for host -> backend
    lua_shared_dict hostmap 10m;

    # ---- Background loader: refresh /etc/nginx/routes.json every 10s ----
    init_worker_by_lua_block {
        local cjson = require "cjson.safe"

        local function load_routes()
            local f, err = io.open("/usr/share/nginx/html/static/application.json", "r")
            if not f then
                ngx.log(ngx.ERR, "routes.json open error: ", err or "")
                return
            end
            local data = f:read("*a"); f:close()

            local new_sum = ngx.md5(data or "")
            local dict = ngx.shared.hostmap
            local old_sum = dict:get("__checksum")

            -- Only refresh if content changed
            if old_sum == new_sum then
                ngx.log(ngx.ERR, "routes.json is unchanged")
                return
            end

            ngx.log(ngx.ERR, "routes.json is updating with new rotues. Reloading")

            local routes, derr = cjson.decode(data)
            if not routes or type(routes) ~= "table" then
                ngx.log(ngx.ERR, "routes.json decode error: ", derr or "")
                return
            end

            dict:flush_all(); dict:flush_expired()

            local n = 0
            for host, backend in pairs(routes) do
                dict:set(host, backend.ContainerURL or "", 0) -- 0 = no expiry
                n = n + 1
            end

            dict:set("__checksum", new_sum, 0)
            ngx.log(ngx.NOTICE, "routes.json loaded entries: ", n)
        end

        local function refresher(premature)
            if premature then return end
            load_routes()
            local ok, terr = ngx.timer.at(10, refresher) -- adjust interval as desired
            if not ok then ngx.log(ngx.ERR, "timer schedule err: ", terr) end
        end

        -- Kick off immediately
        local ok, err = ngx.timer.at(0, refresher)
        if not ok then ngx.log(ngx.ERR, "initial timer err: ", err) end
    }

    # WebSocket helper
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    server {
        listen 80;
        listen 32100;
        server_name _;

        # -------- Static site (home-page) and error page --------
        location @static {
            root /usr/share/nginx/html;
            index index.html;
        }

        location = /__log_test {
            content_by_lua_block {
                ngx.log(ngx.NOTICE, "manual test log from /__log_test");
                ngx.say("ok");
            }
        }

        location = /custom_50x.html {
            root /usr/share/nginx/html;
            internal;
        }

        # Main router
        location / {
            set $backend "";

            rewrite_by_lua_block {
                local host = ngx.var.host or ""
                local backend = ngx.shared.hostmap:get(host)

                -- Force static for home page hosts
                if host == "app.localhost" or host == "localhost" then
                    backend = ""
                end

                -- Optional naming convention fallback when no explicit mapping
                if backend == nil then
                    local name = host:match("^([%w%-%.]+)%.localhost$")
                    if name and host ~= "localhost" and host ~= "app.localhost" then
                        backend = "http://q" .. name .. ":80"
                    end
                end

                ngx.var.backend = backend or ""

                -- Static if backend is empty string
                if ngx.var.backend == "" then
                    return ngx.exec("@static")
                end
            }

            # Reverse proxy using resolved backend
            proxy_pass $backend;
            proxy_set_header Host $host;

            # WebSockets
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # No caching
            proxy_no_cache 1;
            proxy_cache_bypass 1;
            proxy_cache off;
            add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
            expires off;

            # Error handling
            error_page 502 503 504 /custom_50x.html;

            # Trace chosen backend
            add_header X-Backend $backend always;
        }
    }
}
